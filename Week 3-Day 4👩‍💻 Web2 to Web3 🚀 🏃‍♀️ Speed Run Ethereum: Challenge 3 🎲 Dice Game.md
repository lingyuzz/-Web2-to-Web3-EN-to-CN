第一部分：欢迎来到掷骰子挑战
Austin: 大家好，我是 Austin。今天我和 Carlos、Etta 在一起。这是 Web2 到 Web3 课程第三周的第 4 天。我们现在深入到了速通挑战中，开始涉及一些在以太坊上构建应用的硬核细节和陷阱。

今天的挑战是“掷骰子（Dice Game）”。这个游戏已经存在了，基本玩法是：你发起一笔交易来掷骰子。如果计算出的随机数符合要求，你就赢了；否则就输了。这个随机数是基于区块哈希（Block Hash）计算的，这是一种“伪随机（Pseudo-random）”。虽然它看起来很随机，但它是可预测的。

第二部分：为什么链上随机数可以被攻击？
Austin: 这个游戏的逻辑是取区块哈希（一个巨大的数字），然后对 16 取模（Mod 16），结果在 0 到 15 之间。如果结果小于或等于 2，你就能赢得奖金池。

核心诡计（The Heart of the Trick）： 在公共、确定性的区块链上，随机性非常棘手。既然计算逻辑是公开的，你可以写一个攻击者合约（Attacker Contract）。

用户不直接调用骰子合约，而是调用你的攻击者合约。

攻击者合约在同一笔交易内，先跑一遍一模一样的随机数计算逻辑。

关键点： 攻击者合约会检查这一卷是不是赢家。如果是赢家，它就支付 0.002 ETH 去掷骰子并领奖；如果预测会输，它就什么都不做。

这样，你只需支付一点 Gas 费来运行检查逻辑，而永远不会损失那 0.002 ETH 的赌注。你只需要一直刷交易，直到等到那个必赢的瞬间再出手。

第三部分：深入剖析骰子合约
Carlos: 这是我最喜欢的挑战，因为我天生就想打破或攻击某些东西。当你把合约部署到以太坊，它将永久存在，全世界的人都可以攻击它。你必须在部署前理解这些攻击原理。

Carlos: 我们来看看代码。随机数的计算逻辑是这样的： bytes32 prevHash = blockhash(block.number - 1); 它使用了前一个区块的哈希值。这个值已经是公开已知的了！ 然后它将 prevHash、合约地址以及一个 Nonce（随机偏移量） 进行打包编码（abi.encodePacked）并进行 Keccak256 哈希计算。 最后：uint256 roll = uint256(hash) % 16;

Austin: 既然计算所需的三个要素（前一块哈希、合约地址、Nonce）在攻击者合约里都能拿到，那么预测结果就易如反掌。

第四部分：实施攻击 (Rigged Roll)
Carlos: 我已经在本地部署了攻击者合约（RiggedRoll）。 在 UI 上，原本我们像“平民”一样一次次去赌，胜率很低。但现在我们点击 Rigged Roll 按钮。

Carlos: 你会发现有些交易会失败（Revert），那是因为攻击者合约预测到了这把会输，所以主动停止了执行。我们要做的就是一直点，直到看到一笔成功的交易——那就是我们赢钱的时候。

Austin: 没错。在测试脚本中，你甚至可以写一个死循环，让它不断尝试，直到找到那个获胜的区块。

第五部分：区块链随机数的替代方案
Carlos: 如果我真的想在链上做一个公平的骰子游戏，有什么好的替代方案？

Austin:

承诺-揭示（Commit-Reveal）模式： 玩家先提交一个哈希值（承诺），稍后再公布原值（揭示）。这更公平但用户体验较差，需要操作两次。

VRF（可验证随机函数）： 比如 Chainlink 的 VRF。你向预言机请求随机数，它会在稍后的回调函数中安全地返回一个可证明的随机数。这更安全，但需要支付费用且有时间延迟。

结语
Austin: 挑战 3 的核心就是：去攻破这个骰子游戏！写一个攻击者合约，确保只有在胜算 100% 的时候才发送赌注。

Carlos: 这是一次非常好的练习。它会让你意识到，区块链上的“隐私”和“随机”与传统软件开发完全不同。

Austin: 祝大家攻击愉快！下关见
